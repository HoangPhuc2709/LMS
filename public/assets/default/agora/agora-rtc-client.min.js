/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!******************************************************!*\
  !*** ./resources/js/parts/agora/agora-rtc-client.js ***!
  \******************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
//import AgoraRTC from 'agora-rtc-sdk'
var AgoraRTC = "";

(function ($) {
  "use strict";

  var liveEndedHtml = "<div class=\"no-result default-no-result d-flex align-items-center justify-content-center flex-column w-100 h-100\">\n        <div class=\"no-result-logo\">\n            <img src=\"/assets/default/img/no-results/support.png\" alt=\"\">\n        </div>\n        <div class=\"d-flex align-items-center flex-column mt-30 text-center\">\n            <h2 class=\"text-dark-blue\">".concat(liveEndedLang, "</h2>\n            <p class=\"mt-5 text-center text-gray font-weight-500\">").concat(redirectToPanelInAFewMomentLang, "</p>\n        </div>\n    </div>");
  var featherIconsConf = {
    width: 20,
    height: 20
  };
  var localTracks = {
    localStream: null,
    remoteStreams: null,
    localShareScreenStream: null,
    cameraIsActive: true,
    micIsActive: true,
    shareScreen: false,
    shareScreenActived: false
  };
  var option = {
    appid: appId,
    token: rtcToken,
    uid: null,
    channel: channelName,
    role: streamRole,
    // host or audience
    audienceLatency: 2
  };
  var RTCClient = /*#__PURE__*/function () {
    function RTCClient(cameraStatus, microphone) {
      _classCallCheck(this, RTCClient);
      // Options for joining a channel
      this.option = {
        appId: '',
        channel: '',
        uid: '',
        token: ''
      };
      this.cameraVideoProfile = '1080p_2'; // https://docs.agora.io/en/Video/video_profile_web?platform=Web
      this.screenVideoProfile = '1080p_1';
      this.client = null;
      this.localStream = null;
      this._eventBus = new (events__WEBPACK_IMPORTED_MODULE_0___default())();
      this.mic = microphone;
      this.camera = cameraStatus;
      this.localStreams = {
        camera: {
          id: "",
          stream: null
        },
        screen: {
          id: "",
          stream: null
        }
      };
    }

    //init client and Join a channel
    _createClass(RTCClient, [{
      key: "joinChannel",
      value: function joinChannel(option) {
        var _this = this;
        return new Promise(function (resolve, reject) {
          _this.client = AgoraRTC.createClient({
            mode: 'rtc',
            codec: "h264"
          });
          _this.client.init(option.appid, function () {
            console.log("init success");
            _this.clientListener();
            _this.client.join(option.token, option.channel, null, function (uid) {
              console.log("join channel: " + _this.option.channel + " success, uid: ", uid);
              _this.option = {
                appid: option.appid,
                token: option.token,
                channel: option.channel,
                uid: uid
              };

              //this.createCameraStream(uid);

              _this.localStreams.camera.id = uid; // keep track of the stream uid

              resolve();
            }, function (err) {
              console.error("client join failed", err);
            });
          }, function (err) {
            reject(err);
            console.error(err);
          });
          console.log("appId", option.appid);
        });
      }
    }, {
      key: "publishCameraStream",
      value: function publishCameraStream() {
        var _this2 = this;
        return new Promise(function (resolve, reject) {
          // Create a local stream
          var localStream = AgoraRTC.createStream({
            streamID: _this2.option.uid,
            audio: _this2.mic,
            video: _this2.camera,
            screen: false
          });
          localStream.setVideoProfile(_this2.cameraVideoProfile);

          // Initialize the local stream
          localStream.init(function () {
            console.log("init local stream success");

            // Publish the local stream
            _this2.client.publish(localStream, function (err) {
              console.log("publish failed");
              console.error(err);
            });
            _this2.localStreams.camera.stream = localStream; // keep track of the camera stream for later

            resolve(localStream);
          }, function (err) {
            reject(err);
            console.error("init local stream failed ", err);
          });
        });
      }
    }, {
      key: "joinChannelAsScreenShare",
      value: function joinChannelAsScreenShare(option) {
        var $this = this;
        return new Promise(function (resolve, reject) {
          var screenStream = AgoraRTC.createStream({
            streamID: $this.option.uid,
            audio: true,
            // Set the audio attribute as false to avoid any echo during the call.
            video: false,
            screen: true // screen stream
            //mediaSource: 'screen', // Firefox: 'screen', 'application', 'window' (select one)
          });

          screenStream.setScreenProfile($this.screenVideoProfile); // set the profile of the screen

          screenStream.init(function () {
            console.log("getScreen successful");
            $this.localStreams.screen.stream = screenStream; // keep track of the screen stream

            $this.toggleCamera(false, true);
            $this.client.publish(screenStream, function (err) {
              console.log("[ERROR] : publish screen stream error: " + err);
            });
            screenStream.on('stopScreenSharing', function (evt) {
              $this._eventBus.emit('stopScreenSharing', evt);
            });
            resolve(screenStream);
          }, function (err) {
            console.log("[ERROR] : getScreen failed", err);
            $this.localStreams.screen.id = ""; // reset screen stream id
            $this.localStreams.screen.stream = null; // reset the screen stream
          });
        });
      }
    }, {
      key: "stopScreenShare",
      value: function stopScreenShare() {
        var _this3 = this;
        return new Promise(function (resolve, reject) {
          if (_this3.localStreams.screen.stream) {
            _this3.localStreams.screen.stream.disableVideo(); // disable the local video stream (will send a mute signal)
            _this3.localStreams.screen.stream.stop(); // stop playing the local stream

            _this3.client.unpublish(_this3.localStreams.screen.stream); // unpublish the screen client
          }

          _this3.localStreams.screen.id = ""; // reset the screen id
          _this3.localStreams.screen.stream = null; // reset the stream obj

          _this3.toggleCamera(true, true);
          resolve(_this3.localStreams.camera.stream);
        });
      }
    }, {
      key: "clientListener",
      value: function clientListener() {
        var _this4 = this;
        var client = this.client;
        client.on('stream-added', function (evt) {
          // The stream is added to the channel but not locally subscribed
          _this4._eventBus.emit('stream-added', evt);
        });
        client.on('stream-subscribed', function (evt) {
          _this4._eventBus.emit('stream-subscribed', evt);
        });
        client.on('stream-removed', function (evt) {
          _this4._eventBus.emit('stream-removed', evt);
        });
        client.on('peer-online', function (evt) {
          _this4._eventBus.emit('peer-online', evt);
        });
        client.on('peer-leave', function (evt) {
          _this4._eventBus.emit('peer-leave', evt);
        });
      }
    }, {
      key: "on",
      value: function on(eventName, callback) {
        this._eventBus.on(eventName, callback);
      }
    }, {
      key: "leaveChannel",
      value: function leaveChannel() {
        var _this5 = this;
        return new Promise(function (resolve, reject) {
          // Leave the channel
          _this5.client.unpublish(_this5.localStream, function (err) {
            console.log(err);
          });
          _this5.client.leave(function () {
            // Stop playing the local stream

            if (_this5.localStreams.camera.stream) {
              if (_this5.localStreams.camera.stream.isPlaying()) {
                _this5.localStreams.camera.stream.stop();
              }
              // Close the local stream
              _this5.localStreams.camera.stream.close();
            }
            _this5.localStreams.camera.id = ""; // reset the camera id
            _this5.localStreams.camera.stream = null; // reset the stream obj
            _this5.client = null;
            resolve();
            console.log("client leaves channel success");
          }, function (err) {
            reject(err);
            console.log("channel leave failed");
            console.error(err);
          });
        });
      }
    }, {
      key: "toggleCamera",
      value: function toggleCamera(enable) {
        var editPublish = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        this.camera = enable;
        var $button = $('#cameraEffect');
        var icon = feather.icons['video'].toSvg(featherIconsConf);
        if (this.localStreams.camera.stream) {
          if (enable) {
            this.localStreams.camera.stream.enableVideo();
            if (editPublish) {
              this.client.publish(this.localStreams.camera.stream);
            }
            $button.addClass('active');
            $button.removeClass('disabled');
          } else {
            this.localStreams.camera.stream.disableVideo();
            if (editPublish) {
              this.client.unpublish(this.localStreams.camera.stream);
            }
            $button.removeClass('active');
            $button.addClass('disabled');
            icon = feather.icons['video-off'].toSvg(featherIconsConf);
          }
        }
        $button.find('.icon').html(icon);
        return true;
      }
    }, {
      key: "toggleMicrophone",
      value: function toggleMicrophone(enable) {
        this.mic = enable;
        if (this.localStreams.camera.stream) {
          if (enable) {
            this.localStreams.camera.stream.enableAudio();
          } else {
            this.localStreams.camera.stream.disableAudio();
          }
        }
        return true;
      }
    }]);
    return RTCClient;
  }(); //
  function createRtc() {
    var rtc = new RTCClient(true, true);
    rtc.on('stream-added', function (evt) {
      var stream = evt.stream;
      console.log("[agora] [stream-added] stream-added", stream.getId());
      rtc.client.subscribe(stream);

      /*if (localTracks.remoteStreams) {
          handleLocalVideoBox(true);
      }*/
    });

    rtc.on('stream-subscribed', function (evt) {
      var stream = evt.stream;
      console.log("[agora] [stream-subscribed] stream-added", stream.getId());
      localTracks.remoteStreams = stream;
      console.log('$$$$$$$$$$$$$$$$$$$$$$$$$$');
      console.log(stream);
      console.log('$$$$$$$$$$$$$$$$$$$$$$$$$$');
      stream.play('remote-stream-player', {
        fit: 'cover'
      }, function (err) {
        if (err && err.status !== 'aborted') {
          console.warn('trigger autoplay policy');
        }
      });
      handleLocalVideoBox(true);
      $(".agora-stream-loading").addClass('d-none');
    });
    rtc.on('stream-removed', function (evt) {
      var stream = evt.stream;
      console.log('[agora] [stream-removed] stream-removed', stream.getId());
      localTracks.remoteStreams = null;
      handleLocalVideoBox(false);
    });
    rtc.on('peer-online', function (evt) {});
    rtc.on('stopScreenSharing', function (evt) {
      handleCloseShareScreen();
    });
    rtc.on('peer-leave', function (evt) {
      localTracks.remoteStreams = null;
      handleLocalVideoBox(false);
    });
    window.rtc = rtc;
    joinEvent(rtc);
  }
  createRtc();
  function joinEvent(rtc) {
    rtc.joinChannel(option).then(function () {
      var startAt = streamStartAt && streamStartAt > 0 ? new Date().getTime() / 1000 - streamStartAt : 0;
      handleTimer(startAt);
      rtc.publishCameraStream().then(function (stream) {
        localTracks.localStream = stream;
        stream.play('local-stream-player', {
          fit: 'cover'
        }, function (err) {
          if (err && err.status !== 'aborted') {
            console.warn('trigger autoplay policy');
          }
        });
        $(".agora-stream-loading").addClass('d-none');
      })["catch"](function (err) {
        console.log('publish local error', err);
      });
    })["catch"](function (err) {
      console.log('join channel error', err);
    });
  }
  function leaveEvent() {
    rtc.leaveChannel().then(function () {
      if (redirectAfterLeave) {
        window.location = redirectAfterLeave;
      }
    })["catch"](function (err) {});
  }
  function toggleCamera() {
    if (!localTracks.shareScreenActived) {
      localTracks.cameraIsActive = !localTracks.cameraIsActive;
      rtc.toggleCamera(localTracks.cameraIsActive);
    }
  }
  function toggleMicrophone(effect) {
    localTracks.micIsActive = effect;
    rtc.toggleMicrophone(effect);
  }
  function handleLocalVideoBox(add) {
    var localVideoStream = $('.local-stream');
    var remoteVideoStream = $('.remote-stream');
    if (add) {
      localVideoStream.addClass('has-remote-stream');
      remoteVideoStream.removeClass('d-none');
    } else {
      localVideoStream.removeClass('has-remote-stream');
      remoteVideoStream.addClass('d-none');
    }
  }
  function handleShareScreen() {
    if (!localTracks.shareScreen) {
      localTracks.shareScreen = true;
      localTracks.cameraIsActive = false;
      rtc.joinChannelAsScreenShare(option).then(function (stream) {
        localTracks.localShareScreenStream = stream;
        if (localTracks.localStream) {
          localTracks.localStream.stop();
        }
        localTracks.localStream = null;
      });
    } else {
      handleCloseShareScreen();
    }
  }
  function handleCloseShareScreen() {
    localTracks.cameraIsActive = true;
    localTracks.shareScreen = false;
    rtc.stopScreenShare().then(function (stream) {
      if (localTracks.localShareScreenStream) {
        localTracks.localShareScreenStream.stop();
      }
      localTracks.localShareScreenStream = null;
      if (stream) {
        localTracks.localStream = stream;
      }
    });
  }
  function handleEndStream() {
    if (option.role === 'host') {
      leaveEvent();
    } else {
      $("#player-wrapper-".concat(id)).html(liveEndedHtml);
      setTimeout(function () {
        if (redirectAfterLeave) {
          window.location = redirectAfterLeave;
        }
      }, 3000);
    }
  }
  function handleTimer() {
    var startAt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var streamTimer = $('#streamTimer');
    var hoursLabel = streamTimer.find('.hours');
    var minutesLabel = streamTimer.find('.minutes');
    var secondsLabel = streamTimer.find('.seconds');
    var totalSeconds = startAt;
    setInterval(setTime, 1000);
    function setTime() {
      ++totalSeconds;
      var seconds = pad(Math.floor(totalSeconds % 60));
      var minutes = pad(Math.floor(totalSeconds / 60 % 60));
      var hours = pad(Math.floor(totalSeconds / (60 * 60) % 24));
      hoursLabel.html(hours);
      minutesLabel.html(minutes);
      secondsLabel.html(seconds);
    }
    function pad(val) {
      var valString = val + "";
      if (valString.length < 2) {
        return "0" + valString;
      } else {
        return valString;
      }
    }
  }
  $('body').on('click', '#leave', function (e) {
    var $this = $(this);
    var sessionId = $this.attr('data-id');
    $this.addClass('loadingbar primary').prop('disabled', true);
    var path = '/panel/sessions/' + sessionId + '/endAgora';
    $.get(path, function (result) {
      if (result && result.code === 200) {
        handleEndStream();
      }
    });
  });
  $('body').on('click', '#shareScreen', function (e) {
    handleShareScreen();
  });
  $('body').on('click', '#microphoneEffect', function (e) {
    var $this = $(this);
    var icon = feather.icons['mic'].toSvg(featherIconsConf);
    if (localTracks.micIsActive) {
      if ($this.hasClass('active')) {
        $this.removeClass('active');
        $this.addClass('disabled');
        icon = feather.icons['mic-off'].toSvg(featherIconsConf);
        toggleMicrophone(false);
      } else {
        $this.addClass('active');
        $this.removeClass('disabled');
        toggleMicrophone(true);
      }
    }
    $this.find('.icon').html(icon);
  });
  $('body').on('click', '#cameraEffect', function (e) {
    toggleCamera();
  });
  $('body').on('click', '#collapseBtn', function () {
    var $tabs = $('.agora-tabs');
    $tabs.toggleClass('show');
  });
  $('body').on('click', '#handleUsersJoin', function (e) {
    var $this = $(this);
    var notActive = $this.hasClass('dont-join-users');
    if (notActive) {
      $this.find('span').text(joinIsActiveLang);
    } else {
      $this.find('span').text(joiningIsDisabledLang);
    }
    $this.toggleClass('dont-join-users');
    $this.prop('disabled', true);
    $.get("/panel/sessions/".concat(sessionId, "/toggleUsersJoinToAgora"), function (result) {
      if (result) {
        $.toast({
          heading: result.heading,
          text: result.text,
          bgColor: result.icon === 'error' ? '#f63c3c' : '#43d477',
          textColor: 'white',
          hideAfter: 10000,
          position: 'bottom-right',
          icon: result.icon
        });
      }
      $this.prop('disabled', false);
    });
  });
})(jQuery);
})();

/******/ })()
;